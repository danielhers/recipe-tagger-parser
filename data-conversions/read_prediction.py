# Author: Theresa Schmidt, 2021 <theresas@coli.uni-saarland.de>

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


"""
Creates CoNLL-U formatted tsv files from our tagger's or parser's output files.
Also creates files for error analysis.

1. Analysis mode (default): Takes AllenNLP prediction for sequence tags and
   complementary annotated (gold) file. Prints all columns of the annotated
   file plus an extra column for wrongly predicted tokens into a tab separated file.
2. tagger prediction2conllu: takes a tagging prediction file (json format) and
   writes a CoNLL-U file with the given columns.
3. parser prediction2conllu: takes a parsing prediction file (json format) and
   writes a CoNLL-U file with the given columns.

Tested with Python 3.7

References:
    - Lin et al. (2020).
      A  recipe  for  creating  multimodal  aligned datasets for sequential tasks.
      In Proceedings of the58th Annual Meeting of the Association for Computational Linguistics, pages 4871â€“4884, Online.
      Association for Computational Linguistics.
    - CoNLL-U: https://universaldependencies.org/format.html
"""

import argparse
import json
from ast import literal_eval
import logging


def read_prediction_tokens(pred_file):
    """
    Reads in the tokens from the tagger's output file.

    Returns: a String list
    """
    tokens = []
    with open(pred_file, encoding="utf-8") as f:
        for line in f:
            j = json.loads(line)
            tokens.extend(j["words"])
    return tokens


def read_prediction_tags(pred_file):
    """
    Reads in the predicted tags from the tagger's output file. Or the
    tags used as part of the input for the parser.
    Also determines the source of the data, i.e. whether it was
    generated by the tagger or the parser.

    Returns: a String list with the predicted tags.
    """
    model_type = None
    tags = []
    with open(pred_file, encoding="utf-8") as f:
        for line in f:
            j = json.loads(line)
            try:
                tags.extend(j["tags"])
                model_type = "tagger"
            except KeyError:
                tags.extend(j["pos"])
                model_type = "parser"
    return tags, model_type


def read_prediction_dependencies(pred_file):
    """
    Reads in the predictions from the parser's output file.

    Returns: two String list with the predicted heads and dependency names, respectively.
    """
    heads = []
    deps = []
    with open(pred_file, encoding="utf-8") as f:
        for line in f:
            j = json.loads(line)
            heads.extend(j["predicted_heads"])
            deps.extend(j["predicted_dependencies"])
    heads = list(map(str, heads))
    return heads, deps


def write_with_misjudgements(gold, prediction, goldlines, out_file):
    """
    Writes a tsv file with the first columns repeating the gold annotated
    file. The last column contains all predictions that do not match the
    gold annotation. If the prediction was correct, the last column in
    that line stays empty.
    """
    with open(out_file, "w", encoding="utf-8") as f:
        for g, p, line in zip(gold, prediction, goldlines):
            s = "\t".join(line)
            if g != p:
                s += "\t" + str(p)
            f.write(s + "\n")


def _read_gold_conllu_simplified(gold_file):
    """
    Reads in the gold annotation from a file in CoNLL-U format.
    WARNING: Does not read in extra edges in 9th column!

    Returns:
        - tags: a String list containing one sequence tag per line.
                E.g. [B-Kochschritt, L-Kochschritt, U-Zutat, O]
        - heads: a String list containing one head reference (its token ID)
                 per line.
        - deps: a String list containing one dependency name per line for the
                relation between the token in that line and the token at the
                ID of 'head'.
        - lines: a list list containing the original line split at "\t"
    """
    tags = []
    heads = []
    deps = []
    lines = []
    with open(gold_file, encoding="utf-8") as f:
        for line in f:
            if line == "\n":
                continue
            line = line.split("\t")
            try:
                tags.append(line[4])
                heads.append(line[6])
                deps.append(line[7])
            except IndexError:
                raise IndexError(
                    f"Gold file {gold_file} probably isn't written in CoNLL-U format."
                )
            lines.append(line[:-1])
    return tags, heads, deps, lines


def read_gold_conllu(gold_file):
    """
    Reads in the gold annotation file in CoNLL-U format (all dependencies,
    i.e. multiple dependency relations per token, if applicable).

    Returns:
        - unlabelled: a list of sets with head token ID's;
           len(unlabelled) = num_tokens(gold_file)
        - labelled: a list of sets with (head, dependency name) pairs;
           len(labelled) = num_tokens(gold_file)
    """
    labelled = []
    unlabelled = []
    with open(gold_file, "r", encoding="utf-8") as f:
        for line in f:
            if line == "\n":
                continue
            line = line.split("\t")
            edges = set()
            edges.add((line[6], line[7]))
            if line[8] != "_":
                for edge in literal_eval(line[8]):
                    edges.add(edge)
            heads = set([str(h) for h, d in edges])
            labelled.append(edges)
            unlabelled.append(heads)
    return unlabelled, labelled


def read_gold_conll2003(gold_file):
    """
    Reads in the gold annotation from a file in CoNLL 2003 format.

    Returns:
        - gold: a String list containing one sequence tag per token.
                E.g. [B-Kochschritt, L-Kochschritt, U-Zutat, O]
        - lines: a list list containing the original line split at "\t"
    """
    gold = []
    lines = []
    with open(gold_file, encoding="utf-8") as f:
        for line in f:
            if line == "\n":
                continue
            line = line.strip().split("\t")
            gold.append(line[3])
            lines.append(line)
    return gold, lines


def taggingcolumns2conllu(outfile, tokens, tags, pos_tags=None, filemode="w"):
    """
    Takes tokens and tags and writes them into a tsv file in CoNLL-U format.
    Domain-specific tags are required, POS tags are optional.
    CoNLL-U columns: ID FORM LEMMA UPOS XPOS FEATS HEAD DEPREL DEPS MISC

    All tokens are annotated with HEAD = 0 and DEPREL = root, so the parser's
    dataset reader can read in the file without errors.
    """

    # double-check input
    if len(tokens) != len(tags):
        raise ValueError(
            "Will not zip tokens and tags: number of tokens in tokens and "
            "number of tags in tags must be the same. Got ",
            len(tokens),
            "and",
            len(tags),
        )
    # write file: one token per line
    with open(outfile, filemode, encoding="utf-8") as o:
        if pos_tags:
            for (i, (_token, _pos, _tag)) in enumerate(zip(tokens, pos_tags, tags)):
                # need to start counting from 1 bc 0 is used for None-node
                o.write(
                    str(i + 1)
                    + "\t"
                    + _token
                    + "\t_\t"
                    + _pos
                    + "\t"
                    + _tag
                    + "\t_\t0\troot\t_\t_"
                )
                o.write("\n")
            o.write("\n")
        else:
            for (i, (_token, _tag)) in enumerate(zip(tokens, tags)):
                # need to start counting from 1 bc 0 is used for None-node
                o.write(
                    str(i + 1)
                    + "\t"
                    + _token
                    + "\t_\t_\t"
                    + _tag
                    + "\t_\t0\troot\t_\t_"
                )
                o.write("\n")
            o.write("\n")


def parsercolumns2conllu(outfile, tokens, tags, heads, deps, pos_tags=None):
    """
    Takes tokens, tags and dependency relations and writes them into a tsv file in CoNLL-U format.
    Domain-specific tags are required, POS tags are optional.

    CoNLL-U columns: ID FORM LEMMA UPOS XPOS FEATS HEAD DEPREL DEPS MISC
    """
    # double-check input
    if len(tokens) != len(tags):
        raise ValueError(
            f"Will not zip tokens, tags, heads and deps: number of tokens "
            f"in tokens and number of tags in tags must be the same. "
            f"Got {len(tokens)}, {len(tags)}, {len(heads)} and {len(deps)}."
        )
    # write file: one token per line
    with open(outfile, "w", encoding="utf-8") as o:
        if pos_tags:
            for (i, (_token, _pos, _tag, _head, _dep)) in enumerate(
                zip(tokens, pos_tags, tags, heads, deps)
            ):
                # need to start counting from 1 bc 0 is used for None-node
                o.write(
                    str(i + 1)
                    + "\t"
                    + _token
                    + "\t_\t"
                    + _pos
                    + "\t"
                    + _tag
                    + "\t_\t"
                    + _head
                    + "\t"
                    + _dep
                    + "\t_\t_"
                )
                o.write("\n")
        else:
            for (i, (_token, _tag, _head, _dep)) in enumerate(
                zip(tokens, tags, heads, deps)
            ):
                # need to start counting from 1 bc 0 is used for None-node
                o.write(
                    str(i + 1)
                    + "\t"
                    + _token
                    + "\t_\t_\t"
                    + _tag
                    + "\t_\t"
                    + _head
                    + "\t"
                    + _dep
                    + "\t_\t_"
                )
                o.write("\n")


def execute_analysis(args):
    """
    Reads in a gold annotated file and predicted data.
    Writes a new file where the first columns repeat the gold annotated file.
    The last column contains all predictions that do not match the gold annotation.
    If the prediction was correct, the last column in that line stays empty.
    """

    # Read in prediction for the sequence tagging task
    # and find out whether the predicted items are tags or edges
    pred_tags, model_type = read_prediction_tags(args.pred_file)

    if model_type == "parser":
        if args.conllu:
            # Print feedback to console
            logging.info(
                "Comparing edges in "
                + args.pred_file
                + "\nto edges in"
                + args.gold_file
                + ",\nwriting results into "
                + args.out
            )

            # Read in gold_file
            gold_tags, gold_heads, gold_deps, goldlines = _read_gold_conllu_simplified(
                args.gold_file
            )
            # Read in prediction for the parsing task
            pred_heads, pred_deps = read_prediction_dependencies(args.pred_file)
            # Combine prediction and expectation into a tsv file
            write_with_misjudgements(
                zip(gold_heads, gold_deps),
                zip(pred_heads, pred_deps),
                goldlines,
                args.out,
            )
        elif args.conll2003:
            raise ValueError(
                f"The data in {args.pred_file} was predicted by a parser. Can't be "
                f"evaluated against a file in CoNLL-2003 format (used flag '-c3' for gold file)."
            )

    elif model_type == "tagger":
        # Print feedback to console
        logging.info(
            "Comparing tags in "
            + args.pred_file
            + "\nto tags in"
            + args.gold_file
            + ",\nwriting results into "
            + args.out
        )

        if args.conllu:
            # Read in gold_file in CoNLL-U format
            gold_tags, gold_heads, gold_deps, goldlines = _read_gold_conllu_simplified(
                args.gold_file
            )
        elif args.conll2003:
            # Read in gold file in CoNLL-2003 format (doesn't double-check whether args.gold_file actually
            # is written in CoNLL-2003 format
            gold_tags, goldlines = read_gold_conll2003(args.gold_file)
        # Combine prediction and expectation into a tsv file
        write_with_misjudgements(gold_tags, pred_tags, goldlines, args.out)


def execute_tagger2c(args):
    """
    Takes a prediction file generated by our tagger (i.e. json file) and writes a tsv file in CoNLL-U format.

    CoNLL-U columns: ID FORM LEMMA UPOS XPOS FEATS HEAD DEPREL DEPS MISC
    Realised columns (all other columns contain dummy values): ID FORM _ (UPOS) XPOS _ _ _ _ _
    """
    if args.sent:
        lineflag = False
        with open(args.pred_file, encoding="utf-8") as f:
            for line in f:
                lineflag = True
                j = json.loads(line)
                tokens = j["words"]
                tags = j["tags"]
                taggingcolumns2conllu(args.out, tokens, tags, filemode="a")
            if not lineflag:
                raise IOError(
                    "Empty file"
                )  # Due to formatting and other errors in Lin et al. (2020)'s data,
                # some recipes do not contain text, leaving us with empty files.
                # Empty files could cause further errors; therefore, we want to delete them from the dataset.
    else:
        tokens = read_prediction_tokens(args.pred_file)
        tags, _ = read_prediction_tags(args.pred_file)
        taggingcolumns2conllu(args.out, tokens, tags)


def execute_parse2c(args):
    """
    Takes a prediction file generated by our parser (i.e. json file) and writes a tsv file in CoNLL-U format.

    CoNLL-U columns: ID FORM LEMMA UPOS XPOS FEATS HEAD DEPREL DEPS MISC
    Realised columns (all other columns contain dummy values): ID FORM _ (UPOS) XPOS _ HEAD DEPREL DEPS _
    """
    tokens = read_prediction_tokens(args.pred_file)
    tags, _ = read_prediction_tags(args.pred_file)
    heads, deps = read_prediction_dependencies(args.pred_file)
    parsercolumns2conllu(args.out, tokens, tags, heads, deps)


if __name__ == "__main__":

    # parser for command line arguments
    arg_parser = argparse.ArgumentParser(
        description="""Has three modes. 
        1. Analysis mode (default): Takes AllenNLP prediction for sequence 
          tags and complementary annotated (gold) file. 
          Prints all columns of the annotated file plus an extra column 
          for wrongly predicted tokens into a tab separated file.
        2. tagger prediction2conllu: takes a tagging prediction file (json format) and writes a 
          CoNLL-U file with the given columns.
        3. parser prediction2conllu: takes a parsing prediction file (json format) and writes a 
          CoNLL-U file with the given columns."""
    )
    arg_parser.add_argument(
        "-m",
        "--mode",
        dest="mode",
        help="""Specify mode as described above. Choose one of the following: {analysis, tagger_p2c, parser_p2c}.""",
    )
    arg_parser.add_argument(
        "-p",
        "--prediction",
        metavar="PRED_FILE",
        dest="pred_file",
        required=True,
        help="""Prediction file in json format. Output of AllenNLP parser.""",
    )
    arg_parser.add_argument(
        "-c3",
        "--conll2003",
        dest="conll2003",
        metavar="GOLD_FILE",
        help="""Annotated (gold) file in CoNLL2003 format.""",
    )
    arg_parser.add_argument(
        "-cu",
        "--conllu",
        dest="conllu",
        metavar="GOLD_FILE",
        help="""Annotated (gold) file in CoNLL-U format.""",
    )
    arg_parser.add_argument(
        "-o",
        "--output_file",
        dest="out",
        metavar="OUTPUT_FILE",
        help="""Name of the output file. Default: <prediction file>.tsv in evaluation mode""",
    )
    arg_parser.add_argument(
        "--single-sentences",
        dest="sent",
        const=True,
        default=False,
        action="store_const",
        help="""Implemented only for mode tagger_p2c.""",
    )
    args = arg_parser.parse_args()

    args.debug = False

    # Determine file names in analysis mode
    if args.mode == "analysis" or not args.mode:
        if args.out == None:
            args.out = str(args.pred_file)[:-4] + "tsv"
        if args.conll2003:
            if args.conllu:
                raise IOError(
                    "Two annotated files provided. Please, specify only one annotated file."
                )
            else:
                args.gold_file = args.conll2003
        else:
            if args.conllu:
                args.gold_file = args.conllu
            else:
                raise IOError(
                    "No annotated file provided. Please, specify an annotated file with -c3 or -cu flags."
                )

    # Determine file names for pred2conllu
    elif args.mode.endswith("p2c"):
        if args.out == None:
            args.out = str(args.pred_file)[:-4] + "conllu"

    else:
        raise RuntimeError(
            "Unexpected mode. Please specify one of {analysis, tagger_p2c, parser_p2c}."
        )

    #########################
    #### Start execution ####
    #########################

    if args.mode == "analysis" or not args.mode:
        execute_analysis(args)
    elif args.mode == "tagger_p2c":
        execute_tagger2c(args)
    elif args.mode == "parser_p2c":
        execute_parse2c(args)
    else:
        raise RuntimeError(
            "Unexpected mode. Please specify one of {analysis, tagger_p2c, parser_p2c}."
        )
